package util;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

/**
 * <h1>Util класс для получения соединения</h1>
 * В директории utils хранятся константные данные.
 * <br><br>
 * В этом классе мы храним необходимые данные для подключения к БД, а так-же позвращаем соединение.
 * <br><br>
 * Т.к. это утилитный класс, класс должен быть неизменяем (final) и иметь private конструктор.
 * <br><br>
 * <b>Всё, что будет в этом классе - это получение соединения</b>
 * <hr>
 * <h1>Где на самом деле принято хранить настройки сохранения?</h1>
 * Конфигурационные данные, настройки принято выносить в <i>application.properties</i> файл. Это текстовый файл,
 * который можно менять без перекомпиляции нашего приложения. Этот файл как правло хранится в директории
 * <i>resources</i>.
 * <br><br>
 * <i>application.properties</i> файл представляет из себя обычный текстовый файл, в котором есть ключ-значение.
 * По сути говоря, это аналог нашего ассоциативного массива. И ключи обычно именуются с маленькой буквы и если
 * там несколько слов, то они разделяются через точку.
 */
public final class ConnectionManager {

    private static final String URL_KEY = "db.url";
    private static final String USERNAME_KEY = "db.username";
    private static final String PASSWORD_KEY = "db.password";

    private ConnectionManager() {

    }

    /**
     * <h2>Рассмотрим метод getConnection, а именно как возвращает необходимое соединение:</h2>
     * <ul>
     *     <li>
     *         Создаёт <i>java.util.Properties</i> и по сути просто делигирует вызов в другой getConnection, который ещё
     *         принимает Properties файл. <i>Properties</i> - это по сути обычный класс, старый вариант представления
     *         HashMap, который представляет из себя обычный ассоциативный массив.
     *     </li>
     *     <li>
     *         Далее, он пытается из регистрированных драйверов найти тот, который подходит по URL. Т.е. по сути у него
     *         есть URL, который и является основным для того, чтобы определить какой драйвер подходит, а какой нет.
     *         Но т.к. он не умеет определять по URL какой драйвер подходит для соединения с нашей СУБД, потому что их
     *         бывает много, он проверяет каждый из драйверов, который у него есть в CLASSPATH.
     *     </li>
     *     <li>
     *         Следовательно, если какой-то драйвер не подходит, то получается Exception, который отлавливает и
     *         сохраняет в <i>reason</i>. И так циклом проходит до тех пор, пока рано или поздго не получится
     *         подключиться к Connection. И как только у него получилось соединиться и у него вернулся <i>Connection</i>
     *         без Exception, он возвращает этот Connection.
     *         <br><br>
     *         В противном случае, если не получилось зайти в <i>if (con != null)</i>, он просто в конечном итоге
     *         проверяет, если есть ли Exception, то пробрасывает <i>throw exception</i>.
     *     </li>
     * </ul>
     */
    public static Connection open() {
        // Создаём соединение
        try {
            return DriverManager.getConnection(
                    PropertiesUtil.get(URL_KEY),
                    PropertiesUtil.get(USERNAME_KEY),
                    PropertiesUtil.get(PASSWORD_KEY)
            );
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * До java 1.8 были проблемы с подгрузкой наших драйверов, которые мы подключали через дополнительные
     * библиотеки и они автоматически сами не находились в CLASSPATH. Следственно, их нужно было загружать.
     * Для этого создадим статический блок инициализации и в нём необходимо было сделать Class.forName() и
     * загрузить этот драйвер.
     * <br><br>
     * Т.е. по сути, через Class.forName() мы загружали тот класс, который передали в качестве строки в
     * нашу память JVM. После java 1.8 этот баг называется "metaspace".
     * <br><br>
     * Полное имя класса состоит не только из его названия, но и из пакетов в котором он находится.
     * Таким образом мы явно загружаем его в память и у нас не будет исключения в случае получения соединения
     * у нашего DriverManager, даже если работаем на java до 1.8.
     * <br><br>
     * Естественно у нас есть опять же исключение, которое нужно обернуть в try-catch. Тут обязательно
     * должны пробрасывать потому что если такого класса мы не нашли, то в случае catch продолжаем выполнять
     * наш код и приложение без проблем поднимется.
     * <br><br>
     * <b>Таким образом,</b> у нас будет код, который работает даже в старых версиях java.
     */
    private static void loadDriver() {
        try {
            Class.forName("org.postgresql.Driver");
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        }
    }

    static {
        loadDriver();
    }
}
